(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{335:function(v,_,e){v.exports=e.p+"assets/img/compileAll.f0570125.png"},336:function(v,_,e){v.exports=e.p+"assets/img/ast.5596631a.png"},337:function(v,_,e){v.exports=e.p+"assets/img/compileContent.15d9566b.png"},378:function(v,_,e){"use strict";e.r(_);var r=e(25),o=Object(r.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"简介"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[v._v("#")]),v._v(" 简介")]),v._v(" "),_("p",[v._v("在上一章节中，我们详细讲述了"),_("code",[v._v("虚拟DOM")]),v._v("的相关知识，其中大部分都是"),_("code",[v._v("虚拟DOM")]),v._v("拿到"),_("code",[v._v("vnode")]),v._v("之后所做的事情。那么"),_("code",[v._v("vnode")]),v._v("是怎样生成的呢？这就涉及到我们本章节要研究的内容"),_("code",[v._v("模板编译")]),v._v("。")]),v._v(" "),_("h2",{attrs:{id:"完整渲染流程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#完整渲染流程"}},[v._v("#")]),v._v(" 完整渲染流程")]),v._v(" "),_("p",[v._v("我们在平时使用Vue的开发过程中，可以在模板中使用变量填充，也可以在模板中直接使用JavaScript表达式或者使用自定义的指令等。")]),v._v(" "),_("p",[v._v("这些功能在标准的HTML语法中是不存在的，那为什么会在浏览器正确的展示出来呢，要探究这个问题，我们需要先了解下 Vue 完整渲染流程。")]),v._v(" "),_("p",[_("img",{attrs:{src:e(335),alt:"完整渲染流程"}})]),v._v(" "),_("ol",[_("li",[v._v("用户编写模板：用户通过Vue提供的模板语法声明式的描述界面")]),v._v(" "),_("li",[v._v("模板编译：Vue将用户编写的模板进行解析和处理")]),v._v(" "),_("li",[v._v("render函数：模板编译完成后，输出的就是render函数")]),v._v(" "),_("li",[v._v("vnode：执行render函数，生成vnode")]),v._v(" "),_("li",[v._v("patch：通过diff算法等操作对vnode树进行处理")]),v._v(" "),_("li",[v._v("视图： 处理完毕后的vnode树生成真实的视图")])]),v._v(" "),_("p",[v._v("在这个流程中，我们将前三个阶段称为"),_("code",[v._v("模板编译阶段")]),v._v("，后三个阶段称为"),_("code",[v._v("虚拟DOM阶段")]),v._v("。")]),v._v(" "),_("p",[v._v("所以我们可以得出一个结论，浏览器能够正确渲染出我们使用的模板语法的原因就是Vue在渲染过程中使用了"),_("code",[v._v("模板编译")]),v._v("，而"),_("code",[v._v("模板编译")]),v._v("就是将用户编写的模板通过一系列处理最终生成"),_("code",[v._v("render函数")]),v._v("的过程。")]),v._v(" "),_("h2",{attrs:{id:"ast"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#ast"}},[v._v("#")]),v._v(" AST")]),v._v(" "),_("p",[v._v("我们都知道，我们在"),_("code",[v._v("<template></template>")]),v._v("标签中写的模板对Vue来说就是一堆字符串，那么如何解析这一堆字符串并且从中提取出元素的标签、属性、变量插值等有效信息呢？这就需要借助一个叫做抽象语法树（AST）的东西。")]),v._v(" "),_("p",[v._v("抽象语法树（AbstractSyntaxTree，AST），简称语法树（Syntax tree），是源代码的抽象语法结构的树状表现形式。一个 AST 只包含与分析源文本有关的信息，而跳过任何其他在解析文本时使用的额外内容（例如什么分号，函数参数中的逗号之类的对程序没有意义的东西）")]),v._v(" "),_("p",[v._v("简单来说，如果"),_("code",[v._v("虚拟DOM")]),v._v("是用"),_("code",[v._v("js对象")]),v._v("表示"),_("code",[v._v("真实DOM")]),v._v("，那么"),_("code",[v._v("AST")]),v._v("就是用一种"),_("code",[v._v("特殊的抽象树状结构")]),v._v("表示"),_("code",[v._v("代码的抽象语法结构")]),v._v("。")]),v._v(" "),_("p",[v._v("我们可以借助语法树工具"),_("a",{attrs:{href:"https://astexplorer.net/",target:"_blank",rel:"noopener noreferrer"}},[v._v("AST Explorer"),_("OutboundLink")],1),v._v("直观的感受。")]),v._v(" "),_("p",[_("img",{attrs:{src:e(336),alt:"AST示例"}})]),v._v(" "),_("p",[v._v("上述示例表示了一个简单的"),_("code",[v._v("HTML")]),v._v("片段被转换成了一个"),_("code",[v._v("特殊的树状结构")]),v._v("。这个结构中的属性描述了"),_("code",[v._v("HTML")]),v._v("片段的关键信息。")]),v._v(" "),_("h2",{attrs:{id:"模板编译内部流程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#模板编译内部流程"}},[v._v("#")]),v._v(" 模板编译内部流程")]),v._v(" "),_("p",[v._v("将模板编译成"),_("code",[v._v("render函数")]),v._v("可以分为两个步骤")]),v._v(" "),_("ol",[_("li",[v._v("将模板解析成"),_("code",[v._v("AST")])]),v._v(" "),_("li",[v._v("使用"),_("code",[v._v("AST")]),v._v("生成"),_("code",[v._v("render函数")])])]),v._v(" "),_("p",[v._v("有些同学就比较疑惑，为什么中间要使用"),_("code",[v._v("AST")]),v._v("中转一下，直接将模板生成"),_("code",[v._v("render函数")]),v._v("多好，还省去中转的损耗的性能。实际通过模板语法直接转换为"),_("code",[v._v("render函数")]),v._v("的算法难度比较大，而"),_("code",[v._v("AST")]),v._v("本身就是一种成熟的方案，所以在框架的权衡下使用了"),_("code",[v._v("AST")]),v._v("方案。")]),v._v(" "),_("p",[v._v("在上一章节中，我们说过一种特殊的节点，静态节点。静态节点特性就是只渲染一次，所以为了性能优化，在生成"),_("code",[v._v("AST")]),v._v("之后，生成"),_("code",[v._v("render函数")]),v._v("之前，需要遍历"),_("code",[v._v("AST")]),v._v("，给静态节点增加一个标记，以便后续"),_("code",[v._v("虚拟DOM")]),v._v("处理时，不会重复渲染。")]),v._v(" "),_("p",[v._v("所以，在 Vue 中，模板编译成"),_("code",[v._v("render函数")]),v._v("分为三部分")]),v._v(" "),_("ol",[_("li",[v._v("解析器：将模板解析成"),_("code",[v._v("AST")])]),v._v(" "),_("li",[v._v("优化器：遍历"),_("code",[v._v("AST")]),v._v("标记静态节点")]),v._v(" "),_("li",[v._v("代码生成器：使用"),_("code",[v._v("AST")]),v._v("生成"),_("code",[v._v("render函数")])])]),v._v(" "),_("p",[v._v("这三个阶段在源码中分别对应三个模块，下面给出三个模块的源代码在源码中的路径：")]),v._v(" "),_("ol",[_("li",[v._v("解析器——源码路径："),_("code",[v._v("src/compiler/parser/index.js")])]),v._v(" "),_("li",[v._v("优化器——源码路径："),_("code",[v._v("src/compiler/optimizer.js")])]),v._v(" "),_("li",[v._v("代码生成器——源码路径："),_("code",[v._v("src/compiler/codegen/index.js")])])]),v._v(" "),_("p",[v._v("流程图如下：")]),v._v(" "),_("p",[_("img",{attrs:{src:e(337),alt:"模板编译内部流程"}})])])}),[],!1,null,null,null);_.default=o.exports}}]);